# 事务
> 作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行


<br/>
## 本地事务
> 刚性事务是指严格遵循ACID原则的事务

* **ACID特性**
    * **Atomicity**  原子性 <br/>
        原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。
    
    * **Consistency**  一致性 <br/>
        一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。
    
    * **Isolation**  隔离性 <br/>
        多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 
    
    * **Durability**  持久性 <br/>
		事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

* **事务之间的互相影响**
    * Dirty Read  脏读 <br/>
        A事务读取了B事务没有提交的数据
    
    * Non-Repeatable Read  不可重复读  <br/>
        A事务读取了B事务已经提交的更改数据(针对的update操作) 
    
    * Phantom Read  幻读 <br/>
        A事务读取了B事务已经提交的新增数据(针对的insert操作) 

* **事务隔离级别**
    * Read uncommitted  读未提交 <br/>
        一个事务可以读取另一个未提交事务的数据 <br/>会出现脏读、不可重复读、幻读
    
    * Read committed  读已提交 <br/>
        一个事务要等另一个事务提交后才能读取数据 <br/>   会出现不可重复读、幻读问题（锁定正在读取的行）
    
    * Repeatable read  可重复读  <br/>
        在开始读取数据（事务开启）时，不再允许修改操作 <br/>  会出幻读（锁定所读取的所有行）
    
    * Serializable  序列化 <br/>
        保证所有的情况不会发生（锁表）
	
	MySQL InnoDB 支持4种事务隔离级别，默认是 Repeatable read
	Oracle 支持2种事务隔离级别 Read committed 和 Serializable， 默认是 Read committed

* **Spring事务的传播行为** <br/>
	事务传播行为是Spring框架独有的事务增强特性。<br/>
	
	Spring在 **TransactionDefinition** 接口中规定了7种类型的事务传播行为。<br/>

	**PROPAGATION_REQUIRED** 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。

* ***数据库如何保证数据一致性*** <br/>
		数据库一般由一个数据库文件和一个日志文件组成，在真正操作数据库之前首先会把日志文件写入磁盘，那么当突然断电的时候，即使操作没有完成，在重新启动数据库时候，数据库会根据当前数据的情况进行undo回滚或者是redo前滚，这样就保证了数据的强一致性。

* ***数据库瓶颈 解决方案***
	* master - slave 主从复制与读写分离
	* 垂直切分 (按业务分，简称为分库)
	* 水平切分 (将一个大表拆分为小表，每个小表位于不同的库， 简称分表/分片)

<br/>
## 分布式事务
> 柔性事务是指遵循BASE理论的事务

* **CAP定律**
    * Consistency             一致性
    * Availability            可用性
    * Partition tolerance     分区容错性

	在分布式系统中，在任何数据库设计中，一个Web应用至多只能同时支持上面的两个属性。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在 一致性 与 可用性 之间做出选择。

* **Base理论**
    * Basically Available     基本可用
    * Soft State              软状态
    * Eventually Consistent   最终一致性

	BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

* **结论** 
	* 在互联网领域的绝大多数的场景，都需要牺牲**强一致性**来换取系统的**高可用性**，系统往往只需要保证**最终一致性**

* **解决方案**
	* **XA分布式事务协议** (XA协议中包含着两个角色：事务协调者和事务参与者)
		* **两阶段提交（2PC）**
			* **准备阶段**：事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交.
			
			* **提交阶段**：事务协调器要求每个数据库提交数据。
			
			* 缺点: 
				* 性能问题 <br/>
				XA协议遵循强一致性。在事务执行过程中，各个节点占用着数据库资源，只有当所有节点准备完毕，事务协调者才会通知提交，参与者提交后释放资源。这样的过程有着非常明显的性能问题。

				* 协调者单点故障问题 <br/>
				事务协调者是整个XA模型的核心，一旦事务协调者节点挂掉，参与者收不到提交或是回滚通知，参与者会一直处于中间状态无法完成事务。

				* 丢失消息导致的不一致问题 <br/>
				在XA协议的第二个阶段，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。

		* **三阶段提交（3PC）** <br/>
			3pc是2pc的改进版本，主要是给协调者和参与者都引入了**超时机制**，同时在第一阶段和第二阶段过程中加入了一个**准备阶段**，保障了数据的一致性。

			* CanCommit <br/>
				协调者向参与者发送canCommit消息和事务信息, 在超时时间内收到所有参与者返回的yes，才能进入下一阶段

			* PreCommit <br/>
				协调者会发送preCommit消息给所有参与者，所有参与者收到后会开始执行事务，并记录undo和redo日志，返回ACK消息

			* DoCommit <br/>
				协调者只有在接收到所有ACK消息后会发送doCommit，**如果此时协调者崩溃或者超时，各个参与者则会继续完成这次commit**

			* 总结 <br/>
				3PC主要解决的**单点故障**问题，并**减少阻塞**，因为一旦参与者无法及时收到来自协调者的信息之后，他会默认执行commit，而不会一直持有事务资源并处于阻塞状态。所以这种机制也会导致数据**一致性问题**。

	* **TCC事务** <br/>
		try - confirm - cancel

		* Try <br/>
			完成所有的业务检查(一致性), 预留必须业务资源(准隔离性) <br/>
			例: 确认客户账户余额足够支付(一致性), 锁住客户账户, 商户账户(准隔离性)

		* Confirm <br/>
			使用Try阶段预留的业务资源执行业务(业务操作必须是幂等的), 如果执行出现异常, 要进行重试 <br/>
			例: 执行客户账户扣款, 商户账户入账操作

		* Cancel <br/>
			释放Try阶段预留的业务资源  <br/>
			例: 在这里就是释放客户账户和商户账户的锁

		* 优点 <br/>
			* 解决了跨应用业务操作的原子性问题，在诸如组合支付、账务拆分场景非常实用。
			* TCC实际上把数据库层的二阶段提交上提到了应用层来实现，对于数据库来说是一阶段提交，规避了数据库层的2PC性能低下问题。
		
		* 缺点 <br/>
			TCC的Try、Confirm 和 Cancel 操作功能需业务提供，开发成本高。

	* **异步确保型**（MQ + 本地消息表）	√
		* 将一些同步阻塞的事务操作变为异步的操作，避免对数据库事务的争用
	
	* **最大努力通知型**
		* 最大努力通知型和异步确保型类似，也是基于异步消息执行，只是在消息从MQ到订阅者时，允许在达到最大重试次数之后正常结束事务。	
	

